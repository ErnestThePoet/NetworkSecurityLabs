## Linux 环境下的 C/S 程序
### 上传操作
客户端对于上传操作，首先向服务器发送一个上传请求报文，其中包含用户输入的服务器端文件路径和文件大小。服务端以写入方式打开该文件，若无异常则发送一个上传许可响应，否则发送拒绝上传响应。客户端收到上传许可后，将发送文件，服务端按照先前收到的文件大小读取套接字进行接收。为了支持大文件传输，客户端对文件的读取、发送和服务端对数据的接收、写入都是分块进行的。  
打开文件后，获取文件大小的方法如下所示。
```
size_t GetFileSize(FILE *file)
{
    // 将文件指针指向文件结尾
    fseek(file, 0, SEEK_END);
    const size_t file_size = ftell(file);
    // 使文件指针回到文件开头
    rewind(file);
    return file_size;
}
```
设文件大小为S，分块大小为B，则计算分块数量的代码为：
```
/*
* 目标：文件大小S为0,1,...,B时，分块数量为1；为B+1,B+2,...,2B时，分块数量为2；...
* 直接计算S/B再加1是不可以的，因为S/B在S为0,1,...,B-1时得0，S为B时却得1.
* 改用(S-1)/B再加1，在S为0,1,...,B时得0，为B+1,B+2,...,2B时得1；...
*/
分块数量=(S-1)/B+1;
// 注意若S可以取到0，则S,B必须都使用有符号整数。如使用无符号整数，则使用下列代码计算分块数量：
分块数量=S==0?0:(S-1)/B+1;
```

### 获取服务端文件列表操作
对于获取服务端文件列表操作，客户端向服务端发送获取文件列表请求报文，其中含有指定的路径。服务端获取目录下文件列表的最简单方法是利用`ls`命令，将`ls`命令的输出拷贝到字符数组的代码如下所示：
```
int SendFileList(const char* server_path){
    char command_buffer[100];
    // 先使用cd命令切换到指定路径，再使用ls输出路径下的文件列表。
    // 2>&1将cd的标准错误流重定向到标准输出流，使得我们可以读取cd的错误输出（目录不存在等）。
    // ls的-p选项使得斜杠/会被添加到目录名后面，可明确区分文件与目录。
    sprintf(command_buffer, "cd %s 2>&1 && ls -p", server_path);
    FILE *ls_pipe = popen(command_buffer, "r");

    char file_list_buffer[1024] = "";
    char current_filename_buffer[100];
    while (!feof(ls_pipe) && fgets(current_filename_buffer, sizeof(current_filename_buffer), ls_pipe))
    {
        strcat(file_list_buffer, current_filename_buffer);
    }

    pclose(ls_pipe);

    // send(file_list_buffer)
}
```
然后服务端封装并发送含有文件列表字符串的响应报文。

### 下载操作
对于下载操作，客户端将首先向服务端发送含有服务端文件路径的下载请求报文，服务端收到后打开文件，若成功则返回一个包含文件大小的下载许可响应，否则发回包含拒绝原因的拒绝响应。服务端发送完下载许可后，就将分块读取并发送文件，客户端在此时进行接收。  

### 套接字接收数据的注意事项
值得我们注意的是，TCP套接字的特性是：能保证发送数据的按顺序到达，但取决于传输情况，不能保证一次`recv()`能从缓冲区读出多少数据。为此，当我们期望接收某固定大小的数据时，就需要记录当前总共已读出的字节数，在循环中不断读取套接字，直到总共读取出的字节数达到我们的目标为止。**只要想从套接字中读取固定大小的数据，就一定要采取此方式读取。** 这一读取方式如下所示。
```
int ReadSocket(const int socket, char *buffer, const size_t target_receive_size)
{
    size_t received_size = 0;

    while (received_size < target_receive_size)
    {
        size_t remaining_receive_size = target_receive_size - received_size;
        // 注意ssize_t是有符号整数类型
        ssize_t current_receive_size = recv(
            socket, buffer + received_size, remaining_receive_size, 0);
        if (current_receive_size == -1)
        {
            return -1;
        }

        received_size += current_receive_size;
    }

    return 0;
}
```

## Windows环境下的扫描器程序
### 框架的选择
目前，编写桌面GUI程序的**主流**框架只有下列几种，任选一种即可：
- Qt (C++或Python，跨平台)
- WPF (C#，目前仅限Windows平台)
- Web前端 (JavaScript)

此任务更推荐前两种
### 程序基本工作方式
使用Connect扫描方式进行扫描即可。根据输入的IP地址范围和端口范围，枚举出IP地址-端口组合，分配给各线程进行扫描。Connect扫描原理很简单，当TCP套接字的Connect方法调用失败/超时，就认为端口关闭。实现中，有三点值得注意：
#### 扫描任务的分配
假设有1000个扫描任务（IP地址-端口组合）要分配给300个线程，若直接根据`1000/300=3`来让每个线程执行3个扫描任务，则当为最后一个线程分配任务时，仍有`1000—299*3=103`个任务没有分配。为了较好地解决此问题，在每次分配完一个线程的任务后，根据当前剩余的任务数量和线程数量，重新计算每个线程要执行的任务数量，用于下一个线程的任务分配。此分配方法的伪代码如下：
```
if(总线程数量>总任务数量){
    总线程数量=总任务数量; // 确保每个线程至少执行一个扫描任务
}
剩余任务数量=总任务数量;
剩余线程数量=总线程数量;
当前每个线程要分配的任务数量=剩余任务数量/剩余线程数量;
当前线程的任务集合=空;
for(每个IP地址ip){
    for(每个端口号port){
        当前线程的任务集合.Add({ip,port});
        剩余任务数量--;
        
        if(当前线程的任务集合.Size==当前每个线程要分配的任务数量){
            启动线程;
            当前线程的任务集合=空;
            
            剩余线程数量--;
            
            // 剩余线程数量为0时，说明已经完成了最后一个线程的任务分配。由于给最后一个线程
            // 分配的任务数量一定等于所有剩余的任务数量，因此此时所有任务都已经分配完成，
            // 循环即将退出。
            if(剩余线程数量>0){
                当前每个线程要分配的任务数量=剩余任务数量/剩余线程数量;
            }
        }
    }
}
```
#### Connect超时的设置
若不手动设置连接超时时间，系统就会使用默认的比较长的超时时间，在被扫描的端口关闭时，等待时间较长。为此可以设置连接的最长超时时间，各语言中的实现方法各有不同，可以谷歌"Set socket connect timeout"寻找相关资料。

#### 扫描结果展示时的线程安全
设添加一条扫描结果是通过写入变量S实现的，则如果多个线程同时直接进行写入，就有可能发生访问竞争，导致某些线程写入的数据丢失。因此，在各线程修改S时，需要对S加锁（如互斥锁），确保对S的写入是线程安全的，即当前线程写入S时其他线程无法写入S。高级语言一般都提供了很简单的方式实现线程安全，可自行搜索例子。